// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define emit
#define Q_OBJECT public: QT_WARNING_PUSH Q_OBJECT_NO_OVERRIDE_WARNING static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); virtual int qt_metacall(QMetaObject::Call, int, void **); QT_TR_FUNCTIONS private: QT_OBJECT_GADGET_COMMON QT_DEFINE_TAG_STRUCT(QPrivateSignal); QT_WARNING_POP QT_ANNOTATE_CLASS(qt_qobject, "")
#define Q_OBJECT
#define signals
#define slots
#define STRING_FORMATTER_(T, Conversion) template <> struct std::formatter<T> : std::formatter<std::string> { auto format(const T& x, format_context& ctx) const { return std::formatter<std::string>::format(Conversion, ctx); } }
#define INFO LOG(QtInfoMsg)
#define DEBUG LOG(QtDebugMsg)
#define WARN LOG(QtWarningMsg)
#define CRITICAL LOG(QtCriticalMsg)
#define FATAL LOG(QtFatalMsg)
#define DECLARE_HOOK_ACCESSORS(Type, GetterName, SetterName, MemberName) Type GetterName() const noexcept { return MemberName; } void SetterName(const Type& hook) { MemberName = hook; } template <typename ClassT, typename ReturnT, typename... Args> void SetterName(ClassT* object, ReturnT (ClassT::*hook)(Args...)) { MemberName = [object, hook](Args... args) -> ReturnT { return (object->*hook)(std::forward<Args>(args)...); }; }
